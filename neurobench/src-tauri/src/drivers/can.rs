// CAN Bus Protocol Stack Generator
// Generates CAN bus drivers for automotive/industrial applications

use super::templates::*;

/// CAN configuration
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CanConfig {
    pub instance: String,
    pub bitrate: u32,         // e.g., 500000 for 500 kbps
    pub mode: CanMode,
    pub tx_pin: Option<String>,
    pub rx_pin: Option<String>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub enum CanMode {
    Normal,
    Loopback,
    Silent,
    SilentLoopback,
}

/// Generate CAN driver code
pub fn generate_can_driver(config: &CanConfig, _arch: &McuArch, lang: &DriverLanguage) -> DriverOutput {
    match lang {
        DriverLanguage::C => generate_can_c(config),
        DriverLanguage::Cpp => generate_can_cpp(config),
        DriverLanguage::Rust => generate_can_rust(config),
    }
}

fn generate_can_c(config: &CanConfig) -> DriverOutput {
    let instance = &config.instance;
    let instance_lower = instance.to_lowercase();
    let bitrate = config.bitrate;

    let header = format!(r#"/**
 * CAN Bus Driver for {instance}
 * Auto-generated by NeuroBench
 * Bitrate: {bitrate} bps
 */

#ifndef {instance}_DRIVER_H
#define {instance}_DRIVER_H

#include <stdint.h>
#include <stdbool.h>

// CAN message structure
typedef struct {{
    uint32_t id;
    uint8_t  ide;     // 0=Standard, 1=Extended
    uint8_t  rtr;     // Remote request
    uint8_t  dlc;     // Data length (0-8)
    uint8_t  data[8];
}} CAN_Message_t;

// Function prototypes
void {instance}_Init(void);
bool {instance}_Transmit(CAN_Message_t *msg);
bool {instance}_Receive(CAN_Message_t *msg);
bool {instance}_Available(void);
void {instance}_SetFilter(uint32_t id, uint32_t mask);

#endif // {instance}_DRIVER_H
"#);

    let source = format!(r#"/**
 * CAN Bus Driver for {instance}
 * Auto-generated by NeuroBench
 */

#include "{instance_lower}_driver.h"
#include "stm32f4xx_hal.h"

// CAN handle
CAN_HandleTypeDef h{instance_lower};

// RX FIFO message pending
static volatile bool rx_pending = false;

/**
 * Initialize CAN at {bitrate} bps
 */
void {instance}_Init(void) {{
    h{instance_lower}.Instance = {instance};
    h{instance_lower}.Init.Prescaler = 6;  // Adjust for {bitrate} bps
    h{instance_lower}.Init.Mode = CAN_MODE_NORMAL;
    h{instance_lower}.Init.SyncJumpWidth = CAN_SJW_1TQ;
    h{instance_lower}.Init.TimeSeg1 = CAN_BS1_12TQ;
    h{instance_lower}.Init.TimeSeg2 = CAN_BS2_2TQ;
    h{instance_lower}.Init.TimeTriggeredMode = DISABLE;
    h{instance_lower}.Init.AutoBusOff = ENABLE;
    h{instance_lower}.Init.AutoWakeUp = ENABLE;
    h{instance_lower}.Init.AutoRetransmission = ENABLE;
    h{instance_lower}.Init.ReceiveFifoLocked = DISABLE;
    h{instance_lower}.Init.TransmitFifoPriority = DISABLE;
    
    if (HAL_CAN_Init(&h{instance_lower}) != HAL_OK) {{
        while(1);  // Handle error
    }}
    
    // Configure filter to accept all
    CAN_FilterTypeDef filter;
    filter.FilterBank = 0;
    filter.FilterMode = CAN_FILTERMODE_IDMASK;
    filter.FilterScale = CAN_FILTERSCALE_32BIT;
    filter.FilterIdHigh = 0x0000;
    filter.FilterIdLow = 0x0000;
    filter.FilterMaskIdHigh = 0x0000;
    filter.FilterMaskIdLow = 0x0000;
    filter.FilterFIFOAssignment = CAN_RX_FIFO0;
    filter.FilterActivation = ENABLE;
    HAL_CAN_ConfigFilter(&h{instance_lower}, &filter);
    
    // Start CAN
    HAL_CAN_Start(&h{instance_lower});
    
    // Enable RX interrupt
    HAL_CAN_ActivateNotification(&h{instance_lower}, CAN_IT_RX_FIFO0_MSG_PENDING);
}}

/**
 * Transmit CAN message
 */
bool {instance}_Transmit(CAN_Message_t *msg) {{
    CAN_TxHeaderTypeDef header;
    uint32_t mailbox;
    
    if (msg->ide) {{
        header.ExtId = msg->id;
        header.IDE = CAN_ID_EXT;
    }} else {{
        header.StdId = msg->id;
        header.IDE = CAN_ID_STD;
    }}
    header.RTR = msg->rtr ? CAN_RTR_REMOTE : CAN_RTR_DATA;
    header.DLC = msg->dlc;
    header.TransmitGlobalTime = DISABLE;
    
    return HAL_CAN_AddTxMessage(&h{instance_lower}, &header, msg->data, &mailbox) == HAL_OK;
}}

/**
 * Receive CAN message (non-blocking)
 */
bool {instance}_Receive(CAN_Message_t *msg) {{
    CAN_RxHeaderTypeDef header;
    
    if (HAL_CAN_GetRxFifoFillLevel(&h{instance_lower}, CAN_RX_FIFO0) == 0) {{
        return false;
    }}
    
    if (HAL_CAN_GetRxMessage(&h{instance_lower}, CAN_RX_FIFO0, &header, msg->data) != HAL_OK) {{
        return false;
    }}
    
    msg->id = (header.IDE == CAN_ID_EXT) ? header.ExtId : header.StdId;
    msg->ide = (header.IDE == CAN_ID_EXT) ? 1 : 0;
    msg->rtr = (header.RTR == CAN_RTR_REMOTE) ? 1 : 0;
    msg->dlc = header.DLC;
    
    return true;
}}

/**
 * Check if message available
 */
bool {instance}_Available(void) {{
    return HAL_CAN_GetRxFifoFillLevel(&h{instance_lower}, CAN_RX_FIFO0) > 0;
}}

/**
 * Set acceptance filter
 */
void {instance}_SetFilter(uint32_t id, uint32_t mask) {{
    CAN_FilterTypeDef filter;
    filter.FilterBank = 0;
    filter.FilterMode = CAN_FILTERMODE_IDMASK;
    filter.FilterScale = CAN_FILTERSCALE_32BIT;
    filter.FilterIdHigh = (id >> 16) & 0xFFFF;
    filter.FilterIdLow = id & 0xFFFF;
    filter.FilterMaskIdHigh = (mask >> 16) & 0xFFFF;
    filter.FilterMaskIdLow = mask & 0xFFFF;
    filter.FilterFIFOAssignment = CAN_RX_FIFO0;
    filter.FilterActivation = ENABLE;
    HAL_CAN_ConfigFilter(&h{instance_lower}, &filter);
}}
"#);

    DriverOutput {
        header_file: Some(header),
        source_file: source,
        example_file: None,
        peripheral_type: PeripheralType::CAN,
    }
}

fn generate_can_cpp(config: &CanConfig) -> DriverOutput {
    let instance = &config.instance;
    let class_name = format!("{}Driver", instance);
    let bitrate = config.bitrate;

    let source = format!(r#"/**
 * CAN Bus Driver Class for {instance}
 * Auto-generated by NeuroBench
 */

#pragma once
#include <cstdint>

struct CanMessage {{
    uint32_t id;
    bool extended;
    bool rtr;
    uint8_t dlc;
    uint8_t data[8];
}};

class {class_name} {{
public:
    static constexpr uint32_t BITRATE = {bitrate};
    
    static void init();
    static bool transmit(const CanMessage& msg);
    static bool receive(CanMessage& msg);
    static bool available();
    static void setFilter(uint32_t id, uint32_t mask);
}};
"#);

    DriverOutput {
        header_file: None,
        source_file: source,
        example_file: None,
        peripheral_type: PeripheralType::CAN,
    }
}

fn generate_can_rust(config: &CanConfig) -> DriverOutput {
    let bitrate = config.bitrate;

    let source = format!(r#"//! CAN Bus Driver
//! Auto-generated by NeuroBench

/// CAN configuration
pub const BITRATE: u32 = {bitrate};

/// CAN message
#[derive(Clone, Default)]
pub struct CanMessage {{
    pub id: u32,
    pub extended: bool,
    pub rtr: bool,
    pub dlc: u8,
    pub data: [u8; 8],
}}

/// CAN driver wrapper
pub struct CanDriver<CAN> {{
    can: CAN,
}}

impl<CAN> CanDriver<CAN> {{
    pub fn new(can: CAN) -> Self {{
        Self {{ can }}
    }}
}}

// Implementation depends on the specific HAL crate (e.g., stm32f4xx-hal)
// Example with bxcan crate:
// impl CanDriver<bxcan::Can<CAN1>> {{ ... }}
"#);

    DriverOutput {
        header_file: None,
        source_file: source,
        example_file: None,
        peripheral_type: PeripheralType::CAN,
    }
}
