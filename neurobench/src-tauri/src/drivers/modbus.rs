// Modbus Protocol Stack Generator
// Generates Modbus RTU/TCP drivers for industrial automation

use super::templates::*;

/// Modbus configuration
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ModbusConfig {
    pub mode: ModbusMode,
    pub address: u8,          // Slave address (1-247) or 0 for master
    pub uart_instance: String,
    pub baud_rate: u32,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub enum ModbusMode {
    RtuMaster,
    RtuSlave,
}

/// Generate Modbus driver code
pub fn generate_modbus_driver(config: &ModbusConfig, _arch: &McuArch, lang: &DriverLanguage) -> DriverOutput {
    match lang {
        DriverLanguage::C => generate_modbus_c(config),
        DriverLanguage::Cpp => generate_modbus_cpp(config),
        DriverLanguage::Rust => generate_modbus_rust(config),
    }
}

fn generate_modbus_c(config: &ModbusConfig) -> DriverOutput {
    let uart = &config.uart_instance;
    let baud = config.baud_rate;
    let address = config.address;
    let is_master = matches!(config.mode, ModbusMode::RtuMaster);
    let mode_str = if is_master { "Master" } else { "Slave" };

    let header = format!(r#"/**
 * Modbus RTU {mode_str} Driver
 * Auto-generated by NeuroBench
 * UART: {uart}, Baud: {baud}
 */

#ifndef MODBUS_DRIVER_H
#define MODBUS_DRIVER_H

#include <stdint.h>
#include <stdbool.h>

// Modbus configuration
#define MODBUS_SLAVE_ADDRESS {address}
#define MODBUS_BAUD_RATE {baud}

// Function codes
#define FC_READ_COILS           0x01
#define FC_READ_DISCRETE        0x02
#define FC_READ_HOLDING         0x03
#define FC_READ_INPUT           0x04
#define FC_WRITE_SINGLE_COIL    0x05
#define FC_WRITE_SINGLE_REG     0x06
#define FC_WRITE_MULTI_COILS    0x0F
#define FC_WRITE_MULTI_REGS     0x10

// Register map (customize as needed)
#define REG_INPUT_START     0
#define REG_INPUT_COUNT     10
#define REG_HOLDING_START   0
#define REG_HOLDING_COUNT   10

// Function prototypes
void Modbus_Init(void);
void Modbus_Poll(void);

// Master functions
bool Modbus_ReadHoldingRegisters(uint8_t slave, uint16_t addr, uint16_t count, uint16_t *data);
bool Modbus_WriteSingleRegister(uint8_t slave, uint16_t addr, uint16_t value);
bool Modbus_WriteMultipleRegisters(uint8_t slave, uint16_t addr, uint16_t count, const uint16_t *data);

// Slave callbacks (implement in user code)
extern uint16_t Modbus_ReadInputRegister(uint16_t addr);
extern uint16_t Modbus_ReadHoldingRegister(uint16_t addr);
extern void Modbus_WriteHoldingRegister(uint16_t addr, uint16_t value);

#endif // MODBUS_DRIVER_H
"#);

    let source = format!(r#"/**
 * Modbus RTU {mode_str} Driver
 * Auto-generated by NeuroBench
 */

#include "modbus_driver.h"
#include "{uart}_driver.h"
#include <string.h>

// Frame buffer
static uint8_t frame_buffer[256];
static uint16_t frame_len;

// CRC calculation
static uint16_t modbus_crc16(const uint8_t *data, uint16_t len) {{
    uint16_t crc = 0xFFFF;
    for (uint16_t i = 0; i < len; i++) {{
        crc ^= data[i];
        for (uint8_t j = 0; j < 8; j++) {{
            if (crc & 0x0001) {{
                crc = (crc >> 1) ^ 0xA001;
            }} else {{
                crc >>= 1;
            }}
        }}
    }}
    return crc;
}}

/**
 * Initialize Modbus
 */
void Modbus_Init(void) {{
    {uart}_Init();
}}

/**
 * Send Modbus frame
 */
static void send_frame(const uint8_t *data, uint16_t len) {{
    uint16_t crc = modbus_crc16(data, len);
    {uart}_Transmit(data, len);
    uint8_t crc_bytes[2] = {{ crc & 0xFF, (crc >> 8) & 0xFF }};
    {uart}_Transmit(crc_bytes, 2);
}}

/**
 * Read holding registers (Master)
 */
bool Modbus_ReadHoldingRegisters(uint8_t slave, uint16_t addr, uint16_t count, uint16_t *data) {{
    uint8_t request[6];
    request[0] = slave;
    request[1] = FC_READ_HOLDING;
    request[2] = (addr >> 8) & 0xFF;
    request[3] = addr & 0xFF;
    request[4] = (count >> 8) & 0xFF;
    request[5] = count & 0xFF;
    
    send_frame(request, 6);
    
    // Wait for response (simplified - add timeout in production)
    // HAL_Delay(50);
    
    // Parse response
    uint16_t rx_len = {uart}_Receive(frame_buffer, sizeof(frame_buffer));
    if (rx_len < 5) return false;
    
    // Verify CRC and extract data
    uint8_t byte_count = frame_buffer[2];
    for (uint16_t i = 0; i < count && i * 2 + 3 < rx_len - 2; i++) {{
        data[i] = (frame_buffer[3 + i*2] << 8) | frame_buffer[4 + i*2];
    }}
    
    return true;
}}

/**
 * Write single register (Master)
 */
bool Modbus_WriteSingleRegister(uint8_t slave, uint16_t addr, uint16_t value) {{
    uint8_t request[6];
    request[0] = slave;
    request[1] = FC_WRITE_SINGLE_REG;
    request[2] = (addr >> 8) & 0xFF;
    request[3] = addr & 0xFF;
    request[4] = (value >> 8) & 0xFF;
    request[5] = value & 0xFF;
    
    send_frame(request, 6);
    
    // Wait for echo response
    return true;
}}

/**
 * Poll for incoming requests (Slave mode)
 */
void Modbus_Poll(void) {{
    if ({uart}_Available() < 4) return;
    
    frame_len = {uart}_Receive(frame_buffer, sizeof(frame_buffer));
    if (frame_len < 4) return;
    
    // Verify address
    if (frame_buffer[0] != MODBUS_SLAVE_ADDRESS && frame_buffer[0] != 0) return;
    
    // Verify CRC
    uint16_t rx_crc = frame_buffer[frame_len-2] | (frame_buffer[frame_len-1] << 8);
    uint16_t calc_crc = modbus_crc16(frame_buffer, frame_len - 2);
    if (rx_crc != calc_crc) return;
    
    // Process request
    uint8_t fc = frame_buffer[1];
    uint16_t start_addr = (frame_buffer[2] << 8) | frame_buffer[3];
    uint16_t count = (frame_buffer[4] << 8) | frame_buffer[5];
    
    uint8_t response[256];
    uint16_t resp_len = 0;
    
    switch (fc) {{
        case FC_READ_HOLDING:
            response[resp_len++] = MODBUS_SLAVE_ADDRESS;
            response[resp_len++] = fc;
            response[resp_len++] = count * 2;
            for (uint16_t i = 0; i < count; i++) {{
                uint16_t val = Modbus_ReadHoldingRegister(start_addr + i);
                response[resp_len++] = (val >> 8) & 0xFF;
                response[resp_len++] = val & 0xFF;
            }}
            send_frame(response, resp_len);
            break;
            
        case FC_WRITE_SINGLE_REG:
            Modbus_WriteHoldingRegister(start_addr, count);  // count is actually value
            // Echo request
            send_frame(frame_buffer, 6);
            break;
    }}
}}
"#);

    DriverOutput {
        header_file: Some(header),
        source_file: source,
        example_file: None,
        peripheral_type: PeripheralType::UART,  // Modbus uses UART
    }
}

fn generate_modbus_cpp(config: &ModbusConfig) -> DriverOutput {
    let baud = config.baud_rate;
    let address = config.address;

    let source = format!(r#"/**
 * Modbus RTU Driver Class
 * Auto-generated by NeuroBench
 */

#pragma once
#include <cstdint>

class ModbusDriver {{
public:
    static constexpr uint8_t ADDRESS = {address};
    static constexpr uint32_t BAUD_RATE = {baud};
    
    static void init();
    static void poll();
    
    // Master functions
    static bool readHoldingRegisters(uint8_t slave, uint16_t addr, uint16_t count, uint16_t* data);
    static bool writeSingleRegister(uint8_t slave, uint16_t addr, uint16_t value);
    
    // CRC calculation
    static uint16_t crc16(const uint8_t* data, size_t len);
    
    // Slave callbacks (override in derived class)
    virtual uint16_t onReadInputRegister(uint16_t addr) {{ return 0; }}
    virtual uint16_t onReadHoldingRegister(uint16_t addr) {{ return 0; }}
    virtual void onWriteHoldingRegister(uint16_t addr, uint16_t value) {{}}
}};
"#);

    DriverOutput {
        header_file: None,
        source_file: source,
        example_file: None,
        peripheral_type: PeripheralType::UART,
    }
}

fn generate_modbus_rust(config: &ModbusConfig) -> DriverOutput {
    let baud = config.baud_rate;
    let address = config.address;

    let source = format!(r#"//! Modbus RTU Driver
//! Auto-generated by NeuroBench

/// Modbus configuration
pub const SLAVE_ADDRESS: u8 = {address};
pub const BAUD_RATE: u32 = {baud};

/// Function codes
pub mod function_code {{
    pub const READ_COILS: u8 = 0x01;
    pub const READ_DISCRETE: u8 = 0x02;
    pub const READ_HOLDING: u8 = 0x03;
    pub const READ_INPUT: u8 = 0x04;
    pub const WRITE_SINGLE_COIL: u8 = 0x05;
    pub const WRITE_SINGLE_REG: u8 = 0x06;
}}

/// Calculate Modbus CRC-16
pub fn crc16(data: &[u8]) -> u16 {{
    let mut crc: u16 = 0xFFFF;
    for byte in data {{
        crc ^= *byte as u16;
        for _ in 0..8 {{
            if crc & 0x0001 != 0 {{
                crc = (crc >> 1) ^ 0xA001;
            }} else {{
                crc >>= 1;
            }}
        }}
    }}
    crc
}}

/// Modbus frame structure
pub struct ModbusFrame {{
    pub address: u8,
    pub function: u8,
    pub data: [u8; 252],
    pub len: usize,
}}

impl ModbusFrame {{
    pub fn new() -> Self {{
        Self {{
            address: 0,
            function: 0,
            data: [0; 252],
            len: 0,
        }}
    }}
    
    pub fn read_holding_request(slave: u8, addr: u16, count: u16) -> [u8; 8] {{
        let mut frame = [0u8; 8];
        frame[0] = slave;
        frame[1] = function_code::READ_HOLDING;
        frame[2] = (addr >> 8) as u8;
        frame[3] = addr as u8;
        frame[4] = (count >> 8) as u8;
        frame[5] = count as u8;
        let crc = crc16(&frame[0..6]);
        frame[6] = crc as u8;
        frame[7] = (crc >> 8) as u8;
        frame
    }}
}}
"#);

    DriverOutput {
        header_file: None,
        source_file: source,
        example_file: None,
        peripheral_type: PeripheralType::UART,
    }
}
