// SPI Driver Generator
// Generates SPI drivers for various MCU architectures

use super::templates::*;

/// Generate SPI driver code
pub fn generate_spi_driver(config: &SpiConfig, arch: &McuArch, lang: &DriverLanguage) -> DriverOutput {
    match lang {
        DriverLanguage::C => generate_spi_c(config, arch),
        DriverLanguage::Cpp => generate_spi_cpp(config, arch),
        DriverLanguage::Rust => generate_spi_rust(config, arch),
    }
}

fn generate_spi_c(config: &SpiConfig, _arch: &McuArch) -> DriverOutput {
    let instance = &config.instance;
    let instance_lower = instance.to_lowercase();
    let clock_hz = config.clock_hz;
    
    let mode_cpol = match config.mode {
        SpiMode::Mode0 | SpiMode::Mode1 => "SPI_POLARITY_LOW",
        SpiMode::Mode2 | SpiMode::Mode3 => "SPI_POLARITY_HIGH",
    };
    
    let mode_cpha = match config.mode {
        SpiMode::Mode0 | SpiMode::Mode2 => "SPI_PHASE_1EDGE",
        SpiMode::Mode1 | SpiMode::Mode3 => "SPI_PHASE_2EDGE",
    };

    let header = format!(r#"/**
 * SPI Driver for {instance}
 * Auto-generated by NeuroBench
 * Clock: {clock_hz} Hz
 */

#ifndef {instance}_DRIVER_H
#define {instance}_DRIVER_H

#include <stdint.h>
#include <stdbool.h>

// Configuration
#define {instance}_CLOCK_HZ {clock_hz}

// Function prototypes
void {instance}_Init(void);
void {instance}_DeInit(void);
uint8_t {instance}_TransmitReceive(uint8_t data);
void {instance}_Transmit(const uint8_t *data, uint16_t len);
void {instance}_Receive(uint8_t *data, uint16_t len);
void {instance}_CS_Low(void);
void {instance}_CS_High(void);

#endif // {instance}_DRIVER_H
"#);

    let source = format!(r#"/**
 * SPI Driver for {instance}
 * Auto-generated by NeuroBench
 */

#include "{instance_lower}_driver.h"
#include "stm32f4xx_hal.h"

// SPI handle
SPI_HandleTypeDef h{instance_lower};

/**
 * Initialize {instance}
 */
void {instance}_Init(void) {{
    h{instance_lower}.Instance = {instance};
    h{instance_lower}.Init.Mode = SPI_MODE_MASTER;
    h{instance_lower}.Init.Direction = SPI_DIRECTION_2LINES;
    h{instance_lower}.Init.DataSize = SPI_DATASIZE_8BIT;
    h{instance_lower}.Init.CLKPolarity = {mode_cpol};
    h{instance_lower}.Init.CLKPhase = {mode_cpha};
    h{instance_lower}.Init.NSS = SPI_NSS_SOFT;
    h{instance_lower}.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16;
    h{instance_lower}.Init.FirstBit = SPI_FIRSTBIT_MSB;
    h{instance_lower}.Init.TIMode = SPI_TIMODE_DISABLE;
    h{instance_lower}.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
    
    if (HAL_SPI_Init(&h{instance_lower}) != HAL_OK) {{
        while(1);  // Handle error
    }}
}}

/**
 * Deinitialize {instance}
 */
void {instance}_DeInit(void) {{
    HAL_SPI_DeInit(&h{instance_lower});
}}

/**
 * Transmit and receive single byte
 */
uint8_t {instance}_TransmitReceive(uint8_t data) {{
    uint8_t rx;
    HAL_SPI_TransmitReceive(&h{instance_lower}, &data, &rx, 1, HAL_MAX_DELAY);
    return rx;
}}

/**
 * Transmit multiple bytes
 */
void {instance}_Transmit(const uint8_t *data, uint16_t len) {{
    HAL_SPI_Transmit(&h{instance_lower}, (uint8_t*)data, len, HAL_MAX_DELAY);
}}

/**
 * Receive multiple bytes
 */
void {instance}_Receive(uint8_t *data, uint16_t len) {{
    HAL_SPI_Receive(&h{instance_lower}, data, len, HAL_MAX_DELAY);
}}

/**
 * Assert chip select (active low)
 */
void {instance}_CS_Low(void) {{
    // TODO: Configure CS pin in GPIO init
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_RESET);
}}

/**
 * Deassert chip select
 */
void {instance}_CS_High(void) {{
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET);
}}
"#);

    let example = format!(r#"/**
 * Example: {instance} Read/Write
 */

#include "{instance_lower}_driver.h"

// Example: Read device ID from SPI flash
uint8_t read_device_id(void) {{
    {instance}_CS_Low();
    {instance}_TransmitReceive(0x9F);  // Read ID command
    uint8_t id = {instance}_TransmitReceive(0x00);
    {instance}_CS_High();
    return id;
}}

int main(void) {{
    HAL_Init();
    SystemClock_Config();
    
    {instance}_Init();
    
    uint8_t id = read_device_id();
    // Use device ID...
    
    while(1) {{}}
}}
"#);

    DriverOutput {
        header_file: Some(header),
        source_file: source,
        example_file: Some(example),
        peripheral_type: PeripheralType::SPI,
    }
}

fn generate_spi_cpp(config: &SpiConfig, _arch: &McuArch) -> DriverOutput {
    let instance = &config.instance;
    let class_name = format!("{}Driver", instance);
    let clock_hz = config.clock_hz;

    let source = format!(r#"/**
 * SPI Driver Class for {instance}
 * Auto-generated by NeuroBench
 */

#pragma once
#include <cstdint>

class {class_name} {{
public:
    static constexpr uint32_t CLOCK_HZ = {clock_hz};
    
    static void init();
    static void deinit();
    static uint8_t transfer(uint8_t data);
    static void transmit(const uint8_t* data, size_t len);
    static void receive(uint8_t* data, size_t len);
    
    class ChipSelect {{
    public:
        ChipSelect() {{ csLow(); }}
        ~ChipSelect() {{ csHigh(); }}
    private:
        static void csLow();
        static void csHigh();
    }};
}};
"#);

    DriverOutput {
        header_file: None,
        source_file: source,
        example_file: None,
        peripheral_type: PeripheralType::SPI,
    }
}

fn generate_spi_rust(config: &SpiConfig, _arch: &McuArch) -> DriverOutput {
    let clock_hz = config.clock_hz;

    let source = format!(r#"//! SPI Driver
//! Auto-generated by NeuroBench

use embedded_hal::spi::{{FullDuplex, Mode, Phase, Polarity}};

/// SPI configuration
pub const CLOCK_HZ: u32 = {clock_hz};

/// SPI wrapper with chip select management
pub struct SpiDevice<SPI, CS> {{
    spi: SPI,
    cs: CS,
}}

impl<SPI, CS, E> SpiDevice<SPI, CS>
where
    SPI: FullDuplex<u8, Error = E>,
    CS: embedded_hal::digital::v2::OutputPin,
{{
    pub fn new(spi: SPI, cs: CS) -> Self {{
        Self {{ spi, cs }}
    }}
    
    pub fn transfer(&mut self, data: u8) -> Result<u8, E> {{
        self.cs.set_low().ok();
        let result = nb::block!(self.spi.send(data))?;
        nb::block!(self.spi.read())?;
        self.cs.set_high().ok();
        Ok(result)
    }}
    
    pub fn write(&mut self, data: &[u8]) -> Result<(), E> {{
        self.cs.set_low().ok();
        for &byte in data {{
            nb::block!(self.spi.send(byte))?;
            nb::block!(self.spi.read())?;
        }}
        self.cs.set_high().ok();
        Ok(())
    }}
}}
"#);

    DriverOutput {
        header_file: None,
        source_file: source,
        example_file: None,
        peripheral_type: PeripheralType::SPI,
    }
}
