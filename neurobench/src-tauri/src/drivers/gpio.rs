// GPIO Driver Generator
// Generates GPIO drivers for various MCU architectures

use super::templates::*;

/// Generate GPIO driver code
pub fn generate_gpio_driver(config: &GpioConfig, arch: &McuArch, lang: &DriverLanguage) -> DriverOutput {
    match lang {
        DriverLanguage::C => generate_gpio_c(config, arch),
        DriverLanguage::Cpp => generate_gpio_cpp(config, arch),
        DriverLanguage::Rust => generate_gpio_rust(config, arch),
    }
}

fn generate_gpio_c(config: &GpioConfig, _arch: &McuArch) -> DriverOutput {
    let port = &config.port;
    let pin = config.pin;
    let pin_name = format!("P{}{}", port, pin);
    
    let mode_str = match config.mode {
        GpioMode::Input => "GPIO_MODE_INPUT",
        GpioMode::Output => "GPIO_MODE_OUTPUT_PP",
        GpioMode::AlternateFunction => "GPIO_MODE_AF_PP",
        GpioMode::Analog => "GPIO_MODE_ANALOG",
    };
    
    let pull_str = match config.pull {
        GpioPull::None => "GPIO_NOPULL",
        GpioPull::Up | GpioPull::PullUp => "GPIO_PULLUP",
        GpioPull::Down | GpioPull::PullDown => "GPIO_PULLDOWN",
    };
    
    let speed_str = match config.speed {
        GpioSpeed::Low => "GPIO_SPEED_FREQ_LOW",
        GpioSpeed::Medium => "GPIO_SPEED_FREQ_MEDIUM",
        GpioSpeed::High => "GPIO_SPEED_FREQ_HIGH",
        GpioSpeed::VeryHigh => "GPIO_SPEED_FREQ_VERY_HIGH",
    };

    let header = format!(r#"/**
 * GPIO Driver for {pin_name}
 * Auto-generated by NeuroBench
 */

#ifndef GPIO_{port}{pin}_DRIVER_H
#define GPIO_{port}{pin}_DRIVER_H

#include <stdint.h>
#include <stdbool.h>

// Pin definition
#define {pin_name}_PORT GPIO{port}
#define {pin_name}_PIN  GPIO_PIN_{pin}

// Function prototypes
void {pin_name}_Init(void);
void {pin_name}_Write(bool state);
bool {pin_name}_Read(void);
void {pin_name}_Toggle(void);

#endif // GPIO_{port}{pin}_DRIVER_H
"#);

    let source = format!(r#"/**
 * GPIO Driver for {pin_name}
 * Auto-generated by NeuroBench
 */

#include "gpio_{port}{pin}_driver.h"
#include "stm32f4xx_hal.h"

/**
 * Initialize GPIO pin {pin_name}
 */
void {pin_name}_Init(void) {{
    // Enable GPIO clock
    __HAL_RCC_GPIO{port}_CLK_ENABLE();
    
    GPIO_InitTypeDef GPIO_InitStruct = {{0}};
    
    GPIO_InitStruct.Pin = {pin_name}_PIN;
    GPIO_InitStruct.Mode = {mode_str};
    GPIO_InitStruct.Pull = {pull_str};
    GPIO_InitStruct.Speed = {speed_str};
    
    HAL_GPIO_Init({pin_name}_PORT, &GPIO_InitStruct);
}}

/**
 * Write to GPIO pin
 * @param state: true = HIGH, false = LOW
 */
void {pin_name}_Write(bool state) {{
    HAL_GPIO_WritePin({pin_name}_PORT, {pin_name}_PIN, 
                      state ? GPIO_PIN_SET : GPIO_PIN_RESET);
}}

/**
 * Read GPIO pin state
 * @return true if HIGH, false if LOW
 */
bool {pin_name}_Read(void) {{
    return HAL_GPIO_ReadPin({pin_name}_PORT, {pin_name}_PIN) == GPIO_PIN_SET;
}}

/**
 * Toggle GPIO pin
 */
void {pin_name}_Toggle(void) {{
    HAL_GPIO_TogglePin({pin_name}_PORT, {pin_name}_PIN);
}}
"#);

    let example = format!(r#"/**
 * Example usage of {pin_name} GPIO driver
 */

#include "gpio_{port}{pin}_driver.h"

int main(void) {{
    // Initialize HAL
    HAL_Init();
    
    // Initialize GPIO pin
    {pin_name}_Init();
    
    // Example: Blink LED
    while (1) {{
        {pin_name}_Toggle();
        HAL_Delay(500);  // 500ms delay
    }}
    
    return 0;
}}
"#);

    DriverOutput {
        header_file: Some(header),
        source_file: source,
        example_file: Some(example),
        peripheral_type: PeripheralType::GPIO,
    }
}

fn generate_gpio_cpp(config: &GpioConfig, _arch: &McuArch) -> DriverOutput {
    let port = &config.port;
    let pin = config.pin;
    let class_name = format!("Gpio{}{}", port, pin);

    let header = format!(r#"/**
 * GPIO Driver Class for P{port}{pin}
 * Auto-generated by NeuroBench
 */

#pragma once

#include <cstdint>

class {class_name} {{
public:
    enum class Mode {{ Input, Output, AlternateFunction, Analog }};
    enum class Pull {{ None, Up, Down }};
    
    static void init(Mode mode = Mode::Output, Pull pull = Pull::None);
    static void write(bool state);
    static bool read();
    static void toggle();
    
private:
    static constexpr uint8_t PORT = '{port}';
    static constexpr uint8_t PIN = {pin};
}};
"#);

    let source = format!(r#"/**
 * GPIO Driver Class Implementation
 * Auto-generated by NeuroBench
 */

#include "{class_name}.hpp"
#include "stm32f4xx_hal.h"

void {class_name}::init(Mode mode, Pull pull) {{
    __HAL_RCC_GPIO{port}_CLK_ENABLE();
    
    GPIO_InitTypeDef init{{}};
    init.Pin = GPIO_PIN_{pin};
    init.Mode = (mode == Mode::Output) ? GPIO_MODE_OUTPUT_PP : GPIO_MODE_INPUT;
    init.Pull = (pull == Pull::Up) ? GPIO_PULLUP : 
                (pull == Pull::Down) ? GPIO_PULLDOWN : GPIO_NOPULL;
    init.Speed = GPIO_SPEED_FREQ_HIGH;
    
    HAL_GPIO_Init(GPIO{port}, &init);
}}

void {class_name}::write(bool state) {{
    HAL_GPIO_WritePin(GPIO{port}, GPIO_PIN_{pin}, 
                      state ? GPIO_PIN_SET : GPIO_PIN_RESET);
}}

bool {class_name}::read() {{
    return HAL_GPIO_ReadPin(GPIO{port}, GPIO_PIN_{pin}) == GPIO_PIN_SET;
}}

void {class_name}::toggle() {{
    HAL_GPIO_TogglePin(GPIO{port}, GPIO_PIN_{pin});
}}
"#);

    DriverOutput {
        header_file: Some(header),
        source_file: source,
        example_file: None,
        peripheral_type: PeripheralType::GPIO,
    }
}

fn generate_gpio_rust(config: &GpioConfig, _arch: &McuArch) -> DriverOutput {
    let port_lower = config.port.to_lowercase();
    let port_upper = config.port.to_uppercase();
    let pin = config.pin;

    let source = format!(
r#"//! GPIO Driver for P{port_upper}{pin}
//! Auto-generated by NeuroBench

use embedded_hal::digital::v2::{{OutputPin, InputPin, ToggleableOutputPin}};

/// GPIO Pin P{port_upper}{pin} wrapper
pub struct Gpio{port_upper}{pin}<MODE> {{
    pin: stm32f4xx_hal::gpio::gpio{port_lower}::P{port_upper}{pin}<MODE>,
}}

impl<MODE> Gpio{port_upper}{pin}<MODE> {{
    /// Create new GPIO wrapper
    pub fn new(pin: stm32f4xx_hal::gpio::gpio{port_lower}::P{port_upper}{pin}<MODE>) -> Self {{
        Self {{ pin }}
    }}
}}

impl Gpio{port_upper}{pin}<stm32f4xx_hal::gpio::Output<stm32f4xx_hal::gpio::PushPull>> {{
    /// Set pin high
    pub fn set_high(&mut self) {{
        self.pin.set_high().ok();
    }}
    
    /// Set pin low
    pub fn set_low(&mut self) {{
        self.pin.set_low().ok();
    }}
    
    /// Toggle pin state
    pub fn toggle(&mut self) {{
        self.pin.toggle().ok();
    }}
}}

impl Gpio{port_upper}{pin}<stm32f4xx_hal::gpio::Input<stm32f4xx_hal::gpio::Floating>> {{
    /// Read pin state
    pub fn is_high(&self) -> bool {{
        self.pin.is_high().unwrap_or(false)
    }}
    
    /// Read pin state
    pub fn is_low(&self) -> bool {{
        self.pin.is_low().unwrap_or(false)
    }}
}}
"#, port_upper = port_upper, port_lower = port_lower, pin = pin);

    DriverOutput {
        header_file: None,
        source_file: source,
        example_file: None,
        peripheral_type: PeripheralType::GPIO,
    }
}
