// I2C Driver Generator
// Generates I2C drivers for various MCU architectures

use super::templates::*;

/// Generate I2C driver code
pub fn generate_i2c_driver(config: &I2cConfig, arch: &McuArch, lang: &DriverLanguage) -> DriverOutput {
    match lang {
        DriverLanguage::C => generate_i2c_c(config, arch),
        DriverLanguage::Cpp => generate_i2c_cpp(config, arch),
        DriverLanguage::Rust => generate_i2c_rust(config, arch),
    }
}

fn generate_i2c_c(config: &I2cConfig, _arch: &McuArch) -> DriverOutput {
    let instance = &config.instance;
    let instance_lower = instance.to_lowercase();
    
    let speed_hz = match config.speed {
        I2cSpeed::Standard => 100000,
        I2cSpeed::Fast => 400000,
        I2cSpeed::FastPlus => 1000000,
    };

    let header = format!(r#"/**
 * I2C Driver for {instance}
 * Auto-generated by NeuroBench
 * Speed: {speed_hz} Hz
 */

#ifndef {instance}_DRIVER_H
#define {instance}_DRIVER_H

#include <stdint.h>
#include <stdbool.h>

// Configuration
#define {instance}_SPEED_HZ {speed_hz}

// Function prototypes
void {instance}_Init(void);
bool {instance}_IsDeviceReady(uint8_t addr, uint8_t trials);
bool {instance}_Write(uint8_t addr, uint8_t reg, const uint8_t *data, uint16_t len);
bool {instance}_Read(uint8_t addr, uint8_t reg, uint8_t *data, uint16_t len);
bool {instance}_WriteReg8(uint8_t addr, uint8_t reg, uint8_t value);
uint8_t {instance}_ReadReg8(uint8_t addr, uint8_t reg);

#endif // {instance}_DRIVER_H
"#);

    let source = format!(r#"/**
 * I2C Driver for {instance}
 * Auto-generated by NeuroBench
 */

#include "{instance_lower}_driver.h"
#include "stm32f4xx_hal.h"

// I2C handle
I2C_HandleTypeDef h{instance_lower};

/**
 * Initialize {instance}
 */
void {instance}_Init(void) {{
    h{instance_lower}.Instance = {instance};
    h{instance_lower}.Init.ClockSpeed = {speed_hz};
    h{instance_lower}.Init.DutyCycle = I2C_DUTYCYCLE_2;
    h{instance_lower}.Init.OwnAddress1 = 0;
    h{instance_lower}.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
    h{instance_lower}.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
    h{instance_lower}.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
    h{instance_lower}.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
    
    if (HAL_I2C_Init(&h{instance_lower}) != HAL_OK) {{
        while(1);  // Handle error
    }}
}}

/**
 * Check if device is ready
 */
bool {instance}_IsDeviceReady(uint8_t addr, uint8_t trials) {{
    return HAL_I2C_IsDeviceReady(&h{instance_lower}, addr << 1, trials, 100) == HAL_OK;
}}

/**
 * Write to device register
 */
bool {instance}_Write(uint8_t addr, uint8_t reg, const uint8_t *data, uint16_t len) {{
    return HAL_I2C_Mem_Write(&h{instance_lower}, addr << 1, reg, 
                             I2C_MEMADD_SIZE_8BIT, (uint8_t*)data, len, 
                             HAL_MAX_DELAY) == HAL_OK;
}}

/**
 * Read from device register
 */
bool {instance}_Read(uint8_t addr, uint8_t reg, uint8_t *data, uint16_t len) {{
    return HAL_I2C_Mem_Read(&h{instance_lower}, addr << 1, reg,
                            I2C_MEMADD_SIZE_8BIT, data, len,
                            HAL_MAX_DELAY) == HAL_OK;
}}

/**
 * Write single byte to register
 */
bool {instance}_WriteReg8(uint8_t addr, uint8_t reg, uint8_t value) {{
    return {instance}_Write(addr, reg, &value, 1);
}}

/**
 * Read single byte from register
 */
uint8_t {instance}_ReadReg8(uint8_t addr, uint8_t reg) {{
    uint8_t value = 0;
    {instance}_Read(addr, reg, &value, 1);
    return value;
}}
"#);

    let example = format!(r#"/**
 * Example: {instance} Device Communication
 */

#include "{instance_lower}_driver.h"

#define DEVICE_ADDR 0x68  // Example: MPU6050

int main(void) {{
    HAL_Init();
    SystemClock_Config();
    
    {instance}_Init();
    
    // Check if device is connected
    if ({instance}_IsDeviceReady(DEVICE_ADDR, 3)) {{
        // Read WHO_AM_I register
        uint8_t id = {instance}_ReadReg8(DEVICE_ADDR, 0x75);
        
        // Configure device
        {instance}_WriteReg8(DEVICE_ADDR, 0x6B, 0x00);  // Wake up
    }}
    
    while(1) {{}}
}}
"#);

    DriverOutput {
        header_file: Some(header),
        source_file: source,
        example_file: Some(example),
        peripheral_type: PeripheralType::I2C,
    }
}

fn generate_i2c_cpp(config: &I2cConfig, _arch: &McuArch) -> DriverOutput {
    let instance = &config.instance;
    let class_name = format!("{}Driver", instance);
    
    let speed_hz = match config.speed {
        I2cSpeed::Standard => 100000,
        I2cSpeed::Fast => 400000,
        I2cSpeed::FastPlus => 1000000,
    };

    let source = format!(r#"/**
 * I2C Driver Class for {instance}
 * Auto-generated by NeuroBench
 */

#pragma once
#include <cstdint>

class {class_name} {{
public:
    static constexpr uint32_t SPEED_HZ = {speed_hz};
    
    static void init();
    static bool isDeviceReady(uint8_t addr, uint8_t trials = 3);
    static bool write(uint8_t addr, uint8_t reg, const uint8_t* data, size_t len);
    static bool read(uint8_t addr, uint8_t reg, uint8_t* data, size_t len);
    
    template<typename T>
    static bool writeReg(uint8_t addr, uint8_t reg, T value) {{
        return write(addr, reg, reinterpret_cast<const uint8_t*>(&value), sizeof(T));
    }}
    
    template<typename T>
    static T readReg(uint8_t addr, uint8_t reg) {{
        T value{{}};
        read(addr, reg, reinterpret_cast<uint8_t*>(&value), sizeof(T));
        return value;
    }}
}};
"#);

    DriverOutput {
        header_file: None,
        source_file: source,
        example_file: None,
        peripheral_type: PeripheralType::I2C,
    }
}

fn generate_i2c_rust(config: &I2cConfig, _arch: &McuArch) -> DriverOutput {
    let speed_hz = match config.speed {
        I2cSpeed::Standard => 100000,
        I2cSpeed::Fast => 400000,
        I2cSpeed::FastPlus => 1000000,
    };

    let source = format!(r#"//! I2C Driver
//! Auto-generated by NeuroBench

use embedded_hal::blocking::i2c::{{Read, Write, WriteRead}};

/// I2C configuration
pub const SPEED_HZ: u32 = {speed_hz};

/// I2C device wrapper
pub struct I2cDevice<I2C> {{
    i2c: I2C,
    address: u8,
}}

impl<I2C, E> I2cDevice<I2C>
where
    I2C: Read<Error = E> + Write<Error = E> + WriteRead<Error = E>,
{{
    pub fn new(i2c: I2C, address: u8) -> Self {{
        Self {{ i2c, address }}
    }}
    
    pub fn is_connected(&mut self) -> bool {{
        let mut buf = [0u8; 1];
        self.i2c.read(self.address, &mut buf).is_ok()
    }}
    
    pub fn write_reg(&mut self, reg: u8, data: &[u8]) -> Result<(), E> {{
        let mut buf = [0u8; 17];  // 1 reg + 16 data max
        buf[0] = reg;
        buf[1..=data.len()].copy_from_slice(data);
        self.i2c.write(self.address, &buf[..=data.len()])
    }}
    
    pub fn read_reg(&mut self, reg: u8, buf: &mut [u8]) -> Result<(), E> {{
        self.i2c.write_read(self.address, &[reg], buf)
    }}
    
    pub fn write_reg8(&mut self, reg: u8, value: u8) -> Result<(), E> {{
        self.write_reg(reg, &[value])
    }}
    
    pub fn read_reg8(&mut self, reg: u8) -> Result<u8, E> {{
        let mut buf = [0u8; 1];
        self.read_reg(reg, &mut buf)?;
        Ok(buf[0])
    }}
}}
"#);

    DriverOutput {
        header_file: None,
        source_file: source,
        example_file: None,
        peripheral_type: PeripheralType::I2C,
    }
}
