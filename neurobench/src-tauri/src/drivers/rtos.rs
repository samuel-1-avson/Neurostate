// RTOS Generator Module
// Generates FreeRTOS task and scheduling code for embedded applications

use super::templates::*;

/// RTOS configuration
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct RtosConfig {
    pub rtos_type: RtosType,
    pub tasks: Vec<TaskConfig>,
    pub use_queues: bool,
    pub use_semaphores: bool,
    pub use_mutexes: bool,
    pub heap_size_kb: u32,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub enum RtosType {
    FreeRtos,
    Zephyr,
    ThreadX,
    CmsisRtos2,
}

/// Task configuration
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct TaskConfig {
    pub name: String,
    pub priority: u8,          // 0-31 typically
    pub stack_size: u32,       // in words
    pub period_ms: Option<u32>, // for periodic tasks
    pub handler_name: String,
}

/// Generate RTOS code
pub fn generate_rtos_code(config: &RtosConfig, lang: &DriverLanguage) -> DriverOutput {
    match config.rtos_type {
        RtosType::FreeRtos => generate_freertos(config, lang),
        RtosType::CmsisRtos2 => generate_cmsis_rtos2(config, lang),
        _ => generate_freertos(config, lang), // Default to FreeRTOS
    }
}

fn generate_freertos(config: &RtosConfig, lang: &DriverLanguage) -> DriverOutput {
    match lang {
        DriverLanguage::C => generate_freertos_c(config),
        DriverLanguage::Cpp => generate_freertos_cpp(config),
        DriverLanguage::Rust => generate_freertos_rust(config),
    }
}

fn generate_freertos_c(config: &RtosConfig) -> DriverOutput {
    let heap_size = config.heap_size_kb * 1024;
    let task_count = config.tasks.len();
    
    // Generate task handles
    let task_handles = config.tasks.iter()
        .map(|t| format!("TaskHandle_t x{}Handle;", t.name))
        .collect::<Vec<_>>()
        .join("\n");
    
    // Generate task prototypes
    let task_protos = config.tasks.iter()
        .map(|t| format!("void {}(void *pvParameters);", t.handler_name))
        .collect::<Vec<_>>()
        .join("\n");
    
    // Generate task creation code
    let task_creates = config.tasks.iter()
        .map(|t| format!(
            r#"    xTaskCreate({}, "{}", {}, NULL, {}, &x{}Handle);"#,
            t.handler_name, t.name, t.stack_size, t.priority, t.name
        ))
        .collect::<Vec<_>>()
        .join("\n");
    
    // Generate task implementations
    let task_impls = config.tasks.iter()
        .map(|t| {
            let delay = t.period_ms.map(|p| format!(
                "\n        vTaskDelay(pdMS_TO_TICKS({}));", p
            )).unwrap_or_default();
            
            format!(r#"
/**
 * Task: {}
 * Priority: {}, Stack: {} words
 */
void {}(void *pvParameters) {{
    (void)pvParameters;
    
    // Initialization code
    
    for (;;) {{
        // Task logic here
        {}
    }}
}}"#, t.name, t.priority, t.stack_size, t.handler_name, delay)
        })
        .collect::<Vec<_>>()
        .join("\n");

    let header = format!(r#"/**
 * FreeRTOS Application
 * Auto-generated by NeuroBench
 * Tasks: {task_count}, Heap: {heap_size} bytes
 */

#ifndef RTOS_TASKS_H
#define RTOS_TASKS_H

#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "semphr.h"

// Task handles
{task_handles}

// Task prototypes
{task_protos}

// RTOS initialization
void RTOS_Init(void);
void RTOS_Start(void);

#endif // RTOS_TASKS_H
"#);

    let source = format!(r#"/**
 * FreeRTOS Application
 * Auto-generated by NeuroBench
 */

#include "rtos_tasks.h"

// Task handles
{task_handles}

/**
 * Initialize RTOS resources
 */
void RTOS_Init(void) {{
    // Create tasks
{task_creates}
}}

/**
 * Start RTOS scheduler
 */
void RTOS_Start(void) {{
    vTaskStartScheduler();
    
    // Should never reach here
    for (;;);
}}
{task_impls}

// FreeRTOS hooks
void vApplicationStackOverflowHook(TaskHandle_t xTask, char *pcTaskName) {{
    (void)xTask;
    (void)pcTaskName;
    // Handle stack overflow
    for (;;);
}}

void vApplicationMallocFailedHook(void) {{
    // Handle malloc failure
    for (;;);
}}
"#);

    let example = format!(r#"/**
 * Example: FreeRTOS Application
 */

#include "rtos_tasks.h"

int main(void) {{
    // Initialize hardware
    HAL_Init();
    SystemClock_Config();
    
    // Initialize peripherals
    // ...
    
    // Initialize RTOS
    RTOS_Init();
    
    // Start scheduler
    RTOS_Start();
    
    // Never reached
    return 0;
}}
"#);

    DriverOutput {
        header_file: Some(header),
        source_file: source,
        example_file: Some(example),
        peripheral_type: PeripheralType::GPIO, // Using GPIO as placeholder
    }
}

fn generate_freertos_cpp(config: &RtosConfig) -> DriverOutput {
    let task_count = config.tasks.len();
    
    let task_classes = config.tasks.iter()
        .map(|t| format!(
            r#"
class {name}Task : public RtosTask {{
public:
    {name}Task() : RtosTask("{name}", {priority}, {stack}) {{}}
protected:
    void run() override {{
        while (true) {{
            // Task logic
            delay({period});
        }}
    }}
}};"#,
            name = t.name,
            priority = t.priority,
            stack = t.stack_size,
            period = t.period_ms.unwrap_or(100)
        ))
        .collect::<Vec<_>>()
        .join("\n");

    let source = format!(r#"/**
 * FreeRTOS C++ Application
 * Auto-generated by NeuroBench
 * Tasks: {task_count}
 */

#pragma once
#include "FreeRTOS.h"
#include "task.h"

class RtosTask {{
public:
    RtosTask(const char* name, uint8_t priority, uint32_t stackSize)
        : m_name(name), m_priority(priority), m_stackSize(stackSize) {{}}
    
    void start() {{
        xTaskCreate(taskEntry, m_name, m_stackSize, this, m_priority, &m_handle);
    }}
    
protected:
    virtual void run() = 0;
    void delay(uint32_t ms) {{ vTaskDelay(pdMS_TO_TICKS(ms)); }}
    
private:
    static void taskEntry(void* param) {{
        static_cast<RtosTask*>(param)->run();
    }}
    
    TaskHandle_t m_handle = nullptr;
    const char* m_name;
    uint8_t m_priority;
    uint32_t m_stackSize;
}};
{task_classes}
"#);

    DriverOutput {
        header_file: None,
        source_file: source,
        example_file: None,
        peripheral_type: PeripheralType::GPIO,
    }
}

fn generate_freertos_rust(config: &RtosConfig) -> DriverOutput {
    let task_count = config.tasks.len();
    let heap_size = config.heap_size_kb;
    
    let task_fns = config.tasks.iter()
        .map(|t| format!(
            r#"
/// Task: {name}
/// Priority: {priority}, Stack: {stack} words
fn {handler}(_: *mut c_void) {{
    loop {{
        // Task logic here
        
        // Delay for {period}ms
        vTaskDelay({period} / portTICK_PERIOD_MS);
    }}
}}"#,
            name = t.name,
            priority = t.priority,
            stack = t.stack_size,
            handler = t.handler_name,
            period = t.period_ms.unwrap_or(100)
        ))
        .collect::<Vec<_>>()
        .join("\n");

    let source = format!(r#"//! FreeRTOS Application
//! Auto-generated by NeuroBench
//! Tasks: {task_count}, Heap: {heap_size}KB

#![no_std]
#![no_main]

use core::ffi::c_void;

// FreeRTOS bindings (using freertos-rust or similar crate)
extern "C" {{
    fn xTaskCreate(
        task: extern "C" fn(*mut c_void),
        name: *const i8,
        stack: u32,
        param: *mut c_void,
        priority: u32,
        handle: *mut *mut c_void,
    ) -> i32;
    fn vTaskStartScheduler();
    fn vTaskDelay(ticks: u32);
    static portTICK_PERIOD_MS: u32;
}}
{task_fns}

#[no_mangle]
pub extern "C" fn rtos_init() {{
    unsafe {{
        // Create tasks here
        // xTaskCreate(task_handler, name, stack, null, priority, handle);
    }}
}}

#[no_mangle]
pub extern "C" fn rtos_start() {{
    unsafe {{
        vTaskStartScheduler();
    }}
}}
"#);

    DriverOutput {
        header_file: None,
        source_file: source,
        example_file: None,
        peripheral_type: PeripheralType::GPIO,
    }
}

fn generate_cmsis_rtos2(config: &RtosConfig, lang: &DriverLanguage) -> DriverOutput {
    // For now, generate FreeRTOS compatible code with CMSIS wrappers
    generate_freertos(config, lang)
}
