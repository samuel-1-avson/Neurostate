// UART Driver Generator
// Generates UART/USART drivers for various MCU architectures

use super::templates::*;

/// Generate UART driver code
pub fn generate_uart_driver(config: &UartConfig, arch: &McuArch, lang: &DriverLanguage) -> DriverOutput {
    match lang {
        DriverLanguage::C => generate_uart_c(config, arch),
        DriverLanguage::Cpp => generate_uart_cpp(config, arch),
        DriverLanguage::Rust => generate_uart_rust(config, arch),
    }
}

fn generate_uart_c(config: &UartConfig, _arch: &McuArch) -> DriverOutput {
    let instance = &config.instance;
    let baud = config.baud_rate;
    let instance_lower = instance.to_lowercase();
    
    let parity_str = match config.parity {
        Parity::None => "UART_PARITY_NONE",
        Parity::Even => "UART_PARITY_EVEN",
        Parity::Odd => "UART_PARITY_ODD",
    };
    
    let stop_str = match config.stop_bits {
        StopBits::One => "UART_STOPBITS_1",
        StopBits::OnePointFive => "UART_STOPBITS_1_5",
        StopBits::Two => "UART_STOPBITS_2",
    };

    let dma_section = if config.use_dma {
        format!(r#"
// DMA buffers
#define {instance}_TX_BUFFER_SIZE 256
#define {instance}_RX_BUFFER_SIZE 256

static uint8_t {instance_lower}_tx_buffer[{instance}_TX_BUFFER_SIZE];
static uint8_t {instance_lower}_rx_buffer[{instance}_RX_BUFFER_SIZE];
static volatile uint16_t {instance_lower}_rx_head = 0;
static volatile uint16_t {instance_lower}_rx_tail = 0;

/**
 * Start DMA receive (call once after init)
 */
void {instance}_StartDmaReceive(void) {{
    HAL_UART_Receive_DMA(&h{instance_lower}, {instance_lower}_rx_buffer, {instance}_RX_BUFFER_SIZE);
}}
"#)
    } else {
        String::new()
    };

    let header = format!(r#"/**
 * UART Driver for {instance}
 * Auto-generated by NeuroBench
 * Baud Rate: {baud}
 */

#ifndef {instance}_DRIVER_H
#define {instance}_DRIVER_H

#include <stdint.h>
#include <stdbool.h>

// Configuration
#define {instance}_BAUD_RATE {baud}

// Function prototypes
void {instance}_Init(void);
void {instance}_Transmit(const uint8_t *data, uint16_t len);
void {instance}_TransmitString(const char *str);
uint16_t {instance}_Receive(uint8_t *data, uint16_t max_len);
uint16_t {instance}_Available(void);
void {instance}_Flush(void);

#endif // {instance}_DRIVER_H
"#);

    let source = format!(r#"/**
 * UART Driver for {instance}
 * Auto-generated by NeuroBench
 */

#include "{instance_lower}_driver.h"
#include "stm32f4xx_hal.h"
#include <string.h>

// UART handle
UART_HandleTypeDef h{instance_lower};

// Ring buffer for receive
#define RX_BUFFER_SIZE 256
static uint8_t rx_buffer[RX_BUFFER_SIZE];
static volatile uint16_t rx_head = 0;
static volatile uint16_t rx_tail = 0;
{dma_section}
/**
 * Initialize {instance}
 */
void {instance}_Init(void) {{
    h{instance_lower}.Instance = {instance};
    h{instance_lower}.Init.BaudRate = {baud};
    h{instance_lower}.Init.WordLength = UART_WORDLENGTH_8B;
    h{instance_lower}.Init.StopBits = {stop_str};
    h{instance_lower}.Init.Parity = {parity_str};
    h{instance_lower}.Init.Mode = UART_MODE_TX_RX;
    h{instance_lower}.Init.HwFlowCtl = UART_HWCONTROL_NONE;
    h{instance_lower}.Init.OverSampling = UART_OVERSAMPLING_16;
    
    if (HAL_UART_Init(&h{instance_lower}) != HAL_OK) {{
        // Handle error
        while(1);
    }}
    
    // Enable receive interrupt
    __HAL_UART_ENABLE_IT(&h{instance_lower}, UART_IT_RXNE);
}}

/**
 * Transmit data
 */
void {instance}_Transmit(const uint8_t *data, uint16_t len) {{
    HAL_UART_Transmit(&h{instance_lower}, (uint8_t*)data, len, HAL_MAX_DELAY);
}}

/**
 * Transmit null-terminated string
 */
void {instance}_TransmitString(const char *str) {{
    {instance}_Transmit((const uint8_t*)str, strlen(str));
}}

/**
 * Receive data from ring buffer
 * @return Number of bytes read
 */
uint16_t {instance}_Receive(uint8_t *data, uint16_t max_len) {{
    uint16_t count = 0;
    while (rx_tail != rx_head && count < max_len) {{
        data[count++] = rx_buffer[rx_tail];
        rx_tail = (rx_tail + 1) % RX_BUFFER_SIZE;
    }}
    return count;
}}

/**
 * Get number of bytes available in buffer
 */
uint16_t {instance}_Available(void) {{
    if (rx_head >= rx_tail) {{
        return rx_head - rx_tail;
    }}
    return RX_BUFFER_SIZE - rx_tail + rx_head;
}}

/**
 * Flush receive buffer
 */
void {instance}_Flush(void) {{
    rx_head = 0;
    rx_tail = 0;
}}

/**
 * UART IRQ Handler - add to stm32f4xx_it.c
 */
void {instance}_IRQHandler(void) {{
    if (__HAL_UART_GET_FLAG(&h{instance_lower}, UART_FLAG_RXNE)) {{
        uint8_t byte = (uint8_t)(h{instance_lower}.Instance->DR & 0xFF);
        uint16_t next_head = (rx_head + 1) % RX_BUFFER_SIZE;
        if (next_head != rx_tail) {{
            rx_buffer[rx_head] = byte;
            rx_head = next_head;
        }}
    }}
    HAL_UART_IRQHandler(&h{instance_lower});
}}
"#);

    let example = format!(r#"/**
 * Example: {instance} Echo
 */

#include "{instance_lower}_driver.h"

int main(void) {{
    HAL_Init();
    SystemClock_Config();
    
    {instance}_Init();
    {instance}_TransmitString("Hello from NeuroBench!\r\n");
    
    uint8_t buf[64];
    while (1) {{
        if ({instance}_Available() > 0) {{
            uint16_t len = {instance}_Receive(buf, sizeof(buf));
            {instance}_Transmit(buf, len);  // Echo back
        }}
    }}
}}
"#);

    DriverOutput {
        header_file: Some(header),
        source_file: source,
        example_file: Some(example),
        peripheral_type: PeripheralType::UART,
    }
}

fn generate_uart_cpp(config: &UartConfig, _arch: &McuArch) -> DriverOutput {
    let instance = &config.instance;
    let baud = config.baud_rate;
    let class_name = format!("{}Driver", instance);

    let source = format!(r#"/**
 * UART Driver Class for {instance}
 * Auto-generated by NeuroBench
 */

#pragma once
#include <cstdint>
#include <cstring>

class {class_name} {{
public:
    static constexpr uint32_t BAUD_RATE = {baud};
    static constexpr size_t BUFFER_SIZE = 256;
    
    static void init();
    static void transmit(const uint8_t* data, size_t len);
    static void print(const char* str) {{ transmit(reinterpret_cast<const uint8_t*>(str), strlen(str)); }}
    static size_t receive(uint8_t* data, size_t maxLen);
    static size_t available();
    static void flush();
    
private:
    static uint8_t rxBuffer[BUFFER_SIZE];
    static volatile size_t rxHead, rxTail;
}};
"#);

    DriverOutput {
        header_file: None,
        source_file: source,
        example_file: None,
        peripheral_type: PeripheralType::UART,
    }
}

fn generate_uart_rust(config: &UartConfig, _arch: &McuArch) -> DriverOutput {
    let baud = config.baud_rate;

    let source = format!(r#"//! UART Driver
//! Auto-generated by NeuroBench

use embedded_hal::serial::{{Read, Write}};
use nb::block;

/// UART configuration
pub const BAUD_RATE: u32 = {baud};

/// UART wrapper with buffered receive
pub struct UartDriver<UART> {{
    uart: UART,
    rx_buffer: [u8; 256],
    rx_head: usize,
    rx_tail: usize,
}}

impl<UART> UartDriver<UART>
where
    UART: Read<u8> + Write<u8>,
{{
    pub fn new(uart: UART) -> Self {{
        Self {{
            uart,
            rx_buffer: [0; 256],
            rx_head: 0,
            rx_tail: 0,
        }}
    }}
    
    pub fn write_byte(&mut self, byte: u8) {{
        block!(self.uart.write(byte)).ok();
    }}
    
    pub fn write_bytes(&mut self, data: &[u8]) {{
        for &byte in data {{
            self.write_byte(byte);
        }}
    }}
    
    pub fn print(&mut self, s: &str) {{
        self.write_bytes(s.as_bytes());
    }}
    
    pub fn read_byte(&mut self) -> Option<u8> {{
        match self.uart.read() {{
            Ok(byte) => Some(byte),
            Err(_) => None,
        }}
    }}
    
    pub fn available(&self) -> usize {{
        if self.rx_head >= self.rx_tail {{
            self.rx_head - self.rx_tail
        }} else {{
            256 - self.rx_tail + self.rx_head
        }}
    }}
}}
"#);

    DriverOutput {
        header_file: None,
        source_file: source,
        example_file: None,
        peripheral_type: PeripheralType::UART,
    }
}
