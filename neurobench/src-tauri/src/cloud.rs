// Cloud Sync Module
// Provides project export/import and cloud sharing capabilities

use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fs;
use std::path::Path;
use chrono::{DateTime, Utc};

/// Project export format
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProjectExport {
    pub version: String,
    pub name: String,
    pub description: String,
    pub created_at: String,
    pub mcu_target: String,
    pub files: Vec<ExportedFile>,
    pub config: ProjectConfig,
    pub metadata: HashMap<String, String>,
}

/// Exported file
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExportedFile {
    pub path: String,
    pub content: String,
    pub language: String,
    pub generated: bool,
}

/// Project configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProjectConfig {
    pub mcu: String,
    pub clock_speed: Option<u32>,
    pub rtos: Option<String>,
    pub drivers: Vec<String>,
    pub peripherals: Vec<String>,
}

impl Default for ProjectConfig {
    fn default() -> Self {
        Self {
            mcu: "STM32F407".to_string(),
            clock_speed: Some(168_000_000),
            rtos: None,
            drivers: vec![],
            peripherals: vec![],
        }
    }
}

/// GitHub Gist for sharing
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GistInfo {
    pub id: String,
    pub url: String,
    pub html_url: String,
    pub description: String,
    pub public: bool,
    pub created_at: String,
}

/// Gist file content
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GistFile {
    pub filename: String,
    pub content: String,
}

/// Create a project export
pub fn export_project(
    name: &str,
    description: &str,
    mcu_target: &str,
    files: Vec<ExportedFile>,
    config: ProjectConfig,
) -> Result<String, String> {
    let export = ProjectExport {
        version: "1.0".to_string(),
        name: name.to_string(),
        description: description.to_string(),
        created_at: Utc::now().to_rfc3339(),
        mcu_target: mcu_target.to_string(),
        files,
        config,
        metadata: HashMap::new(),
    };

    serde_json::to_string_pretty(&export)
        .map_err(|e| format!("Failed to serialize project: {}", e))
}

/// Import a project from JSON
pub fn import_project(json: &str) -> Result<ProjectExport, String> {
    serde_json::from_str(json)
        .map_err(|e| format!("Failed to parse project: {}", e))
}

/// Save project export to file
pub fn save_export(project: &ProjectExport, path: &str) -> Result<(), String> {
    let json = serde_json::to_string_pretty(project)
        .map_err(|e| format!("Failed to serialize: {}", e))?;
    
    fs::write(path, json)
        .map_err(|e| format!("Failed to write file: {}", e))
}

/// Load project export from file
pub fn load_export(path: &str) -> Result<ProjectExport, String> {
    let content = fs::read_to_string(path)
        .map_err(|e| format!("Failed to read file: {}", e))?;
    
    import_project(&content)
}

/// Create a shareable link (generates a unique ID)
pub fn generate_share_id() -> String {
    use std::time::{SystemTime, UNIX_EPOCH};
    
    let timestamp = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_millis();
    
    // Simple base62-like encoding
    let chars: Vec<char> = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
        .chars()
        .collect();
    
    let mut id = String::new();
    let mut n = timestamp;
    
    while n > 0 {
        id.push(chars[(n % 62) as usize]);
        n /= 62;
    }
    
    id.chars().rev().collect()
}

/// Prepare files for GitHub Gist
pub fn prepare_gist_files(project: &ProjectExport) -> HashMap<String, GistFile> {
    let mut files = HashMap::new();
    
    // Add project manifest
    let manifest = serde_json::json!({
        "name": project.name,
        "description": project.description,
        "mcu": project.mcu_target,
        "version": project.version,
        "created_at": project.created_at,
    });
    
    files.insert(
        "neurobench.json".to_string(),
        GistFile {
            filename: "neurobench.json".to_string(),
            content: serde_json::to_string_pretty(&manifest).unwrap_or_default(),
        },
    );
    
    // Add README
    let readme = format!(
        "# {}\n\n{}\n\n## MCU Target\n{}\n\n## Files\n{}\n\n---\n*Generated by NeuroBench*\n",
        project.name,
        project.description,
        project.mcu_target,
        project.files.iter()
            .map(|f| format!("- `{}`", f.path))
            .collect::<Vec<_>>()
            .join("\n")
    );
    
    files.insert(
        "README.md".to_string(),
        GistFile {
            filename: "README.md".to_string(),
            content: readme,
        },
    );
    
    // Add project files
    for file in &project.files {
        let filename = Path::new(&file.path)
            .file_name()
            .map(|s| s.to_string_lossy().to_string())
            .unwrap_or_else(|| file.path.clone());
        
        files.insert(
            filename.clone(),
            GistFile {
                filename,
                content: file.content.clone(),
            },
        );
    }
    
    files
}

/// Cloud provider types
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum CloudProvider {
    GitHub,
    GitLab,
    Local,
}

/// Sync status
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SyncStatus {
    pub synced: bool,
    pub last_sync: Option<String>,
    pub remote_url: Option<String>,
    pub provider: Option<String>,
    pub changes_pending: bool,
}

impl Default for SyncStatus {
    fn default() -> Self {
        Self {
            synced: false,
            last_sync: None,
            remote_url: None,
            provider: None,
            changes_pending: false,
        }
    }
}

/// Get file extension language
pub fn get_language(path: &str) -> String {
    match Path::new(path).extension().and_then(|s| s.to_str()) {
        Some("c") => "c",
        Some("h") => "c",
        Some("cpp") | Some("cc") | Some("cxx") => "cpp",
        Some("hpp") | Some("hxx") => "cpp",
        Some("rs") => "rust",
        Some("py") => "python",
        Some("json") => "json",
        Some("md") => "markdown",
        Some("yaml") | Some("yml") => "yaml",
        Some("toml") => "toml",
        _ => "text",
    }.to_string()
}

/// Collect files from a directory for export
pub fn collect_project_files(dir: &str, extensions: &[&str]) -> Result<Vec<ExportedFile>, String> {
    let mut files = Vec::new();
    
    let entries = fs::read_dir(dir)
        .map_err(|e| format!("Failed to read directory: {}", e))?;
    
    for entry in entries {
        let entry = entry.map_err(|e| format!("Failed to read entry: {}", e))?;
        let path = entry.path();
        
        if path.is_file() {
            if let Some(ext) = path.extension() {
                let ext_str = ext.to_string_lossy();
                if extensions.iter().any(|e| *e == ext_str.as_ref() as &str) {
                    let content = fs::read_to_string(&path)
                        .map_err(|e| format!("Failed to read {}: {}", path.display(), e))?;
                    
                    files.push(ExportedFile {
                        path: path.file_name()
                            .map(|s| s.to_string_lossy().to_string())
                            .unwrap_or_default(),
                        content,
                        language: get_language(path.to_str().unwrap_or("")),
                        generated: true,
                    });
                }
            }
        }
    }
    
    Ok(files)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_export_project() {
        let files = vec![
            ExportedFile {
                path: "main.c".to_string(),
                content: "int main() { return 0; }".to_string(),
                language: "c".to_string(),
                generated: true,
            }
        ];
        
        let result = export_project(
            "Test Project",
            "A test project",
            "STM32F407",
            files,
            ProjectConfig::default(),
        );
        
        assert!(result.is_ok());
    }

    #[test]
    fn test_import_project() {
        let json = r#"{
            "version": "1.0",
            "name": "Test",
            "description": "Test",
            "created_at": "2024-01-01T00:00:00Z",
            "mcu_target": "STM32",
            "files": [],
            "config": {
                "mcu": "STM32",
                "clock_speed": 168000000,
                "rtos": null,
                "drivers": [],
                "peripherals": []
            },
            "metadata": {}
        }"#;
        
        let result = import_project(json);
        assert!(result.is_ok());
    }

    #[test]
    fn test_generate_share_id() {
        let id1 = generate_share_id();
        let id2 = generate_share_id();
        
        assert!(!id1.is_empty());
        // IDs should be different (or same if generated in same millisecond)
        assert!(id1.len() > 5);
    }

    #[test]
    fn test_get_language() {
        assert_eq!(get_language("main.c"), "c");
        assert_eq!(get_language("app.cpp"), "cpp");
        assert_eq!(get_language("lib.rs"), "rust");
    }
}
