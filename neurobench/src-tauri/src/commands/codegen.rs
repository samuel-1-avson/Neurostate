// Code Generation Commands

use serde::{Deserialize, Serialize};
use crate::core::*;

/// Supported code generation targets
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum CodeTarget {
    C,
    Cpp,
    Rust,
    Python,
    Verilog,
    MicroPython,
}

/// Generate code from FSM
#[tauri::command]
pub fn generate_code(
    project: FSMProject,
    target: CodeTarget,
) -> Result<GeneratedCode, String> {
    log::info!("Generating {:?} code for project: {}", target, project.name);
    
    let code = match target {
        CodeTarget::C => generate_c(&project),
        CodeTarget::Cpp => generate_cpp(&project),
        CodeTarget::Rust => generate_rust(&project),
        CodeTarget::Python => generate_python(&project),
        CodeTarget::Verilog => generate_verilog(&project),
        CodeTarget::MicroPython => generate_micropython(&project),
    };
    
    Ok(GeneratedCode {
        target,
        filename: format!("{}.{}", project.name.to_lowercase().replace(" ", "_"), extension_for(target)),
        code,
    })
}

/// Get list of supported code generation targets
#[tauri::command]
pub fn get_supported_targets() -> Vec<CodeTargetInfo> {
    vec![
        CodeTargetInfo { target: CodeTarget::C, name: "C".to_string(), extension: "c".to_string() },
        CodeTargetInfo { target: CodeTarget::Cpp, name: "C++".to_string(), extension: "cpp".to_string() },
        CodeTargetInfo { target: CodeTarget::Rust, name: "Rust".to_string(), extension: "rs".to_string() },
        CodeTargetInfo { target: CodeTarget::Python, name: "Python".to_string(), extension: "py".to_string() },
        CodeTargetInfo { target: CodeTarget::Verilog, name: "Verilog".to_string(), extension: "v".to_string() },
        CodeTargetInfo { target: CodeTarget::MicroPython, name: "MicroPython".to_string(), extension: "py".to_string() },
    ]
}

#[derive(Debug, Serialize, Deserialize)]
pub struct GeneratedCode {
    pub target: CodeTarget,
    pub filename: String,
    pub code: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct CodeTargetInfo {
    pub target: CodeTarget,
    pub name: String,
    pub extension: String,
}

fn extension_for(target: CodeTarget) -> &'static str {
    match target {
        CodeTarget::C => "c",
        CodeTarget::Cpp => "cpp",
        CodeTarget::Rust => "rs",
        CodeTarget::Python | CodeTarget::MicroPython => "py",
        CodeTarget::Verilog => "v",
    }
}

// --- Code Generation Templates ---

fn generate_c(project: &FSMProject) -> String {
    let states: Vec<_> = project.nodes.iter().map(|n| n.label.to_uppercase()).collect();
    let state_enum = states.join(",\n    ");
    
    format!(r#"/**
 * {name} - Generated by NeuroBench
 * Target: {target}
 */

#include <stdint.h>
#include <stdbool.h>

typedef enum {{
    {states}
}} State;

static State current_state = {initial};

void fsm_init(void) {{
    current_state = {initial};
    // Entry action for initial state
}}

void fsm_process_event(uint8_t event) {{
    switch (current_state) {{
{cases}
        default:
            break;
    }}
}}

State fsm_get_state(void) {{
    return current_state;
}}
"#,
        name = project.name,
        target = project.target_mcu.clone().unwrap_or_else(|| "Generic".to_string()),
        states = state_enum,
        initial = states.first().cloned().unwrap_or_else(|| "STATE_IDLE".to_string()),
        cases = generate_switch_cases(&project.nodes),
    )
}

fn generate_cpp(project: &FSMProject) -> String {
    format!(r#"/**
 * {name} - Generated by NeuroBench
 * C++ State Machine
 */

#include <cstdint>
#include <functional>

class {class_name} {{
public:
    enum class State {{
{states}
    }};

    {class_name}() : m_state(State::{initial}) {{}}

    void processEvent(uint8_t event) {{
        // State machine logic
    }}

    State getState() const {{ return m_state; }}

private:
    State m_state;
}};
"#,
        name = project.name,
        class_name = project.name.replace(" ", ""),
        states = project.nodes.iter()
            .map(|n| format!("        {}", n.label))
            .collect::<Vec<_>>()
            .join(",\n"),
        initial = project.nodes.first().map(|n| n.label.clone()).unwrap_or_else(|| "IDLE".to_string()),
    )
}

fn generate_rust(project: &FSMProject) -> String {
    format!(r#"//! {} - Generated by NeuroBench

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum State {{
{}
}}

pub struct StateMachine {{
    state: State,
}}

impl StateMachine {{
    pub fn new() -> Self {{
        Self {{ state: State::{} }}
    }}

    pub fn process_event(&mut self, _event: u8) {{
        // State machine logic
    }}

    pub fn state(&self) -> State {{
        self.state
    }}
}}
"#,
        project.name,
        project.nodes.iter()
            .map(|n| format!("    {},", n.label))
            .collect::<Vec<_>>()
            .join("\n"),
        project.nodes.first().map(|n| n.label.clone()).unwrap_or_else(|| "Idle".to_string()),
    )
}

fn generate_python(project: &FSMProject) -> String {
    format!(r#"""
{name} - Generated by NeuroBench
"""

from enum import Enum, auto

class State(Enum):
{states}

class StateMachine:
    def __init__(self):
        self.state = State.{initial}
    
    def process_event(self, event):
        # State machine logic
        pass
    
    def get_state(self):
        return self.state
"#,
        name = project.name,
        states = project.nodes.iter()
            .map(|n| format!("    {} = auto()", n.label.to_uppercase()))
            .collect::<Vec<_>>()
            .join("\n"),
        initial = project.nodes.first().map(|n| n.label.to_uppercase()).unwrap_or_else(|| "IDLE".to_string()),
    )
}

fn generate_verilog(project: &FSMProject) -> String {
    let states: Vec<_> = project.nodes.iter().enumerate()
        .map(|(i, n)| format!("    localparam {} = {};", n.label.to_uppercase(), i))
        .collect();
    
    format!(r#"// {} - Generated by NeuroBench
// Verilog FSM

module {} (
    input wire clk,
    input wire rst_n,
    input wire [7:0] event_in,
    output reg [3:0] state_out
);

{}

    reg [3:0] current_state;
    reg [3:0] next_state;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            current_state <= {};
        else
            current_state <= next_state;
    end

    always @(*) begin
        next_state = current_state;
        case (current_state)
            // State transitions
        endcase
    end

    assign state_out = current_state;

endmodule
"#,
        project.name,
        project.name.to_lowercase().replace(" ", "_"),
        states.join("\n"),
        project.nodes.first().map(|n| n.label.to_uppercase()).unwrap_or_else(|| "IDLE".to_string()),
    )
}

fn generate_micropython(project: &FSMProject) -> String {
    generate_python(project) // Similar to Python for now
}

fn generate_switch_cases(nodes: &[FSMNode]) -> String {
    nodes.iter()
        .map(|n| format!(
            "        case {}:\n            // TODO: Handle state\n            break;",
            n.label.to_uppercase()
        ))
        .collect::<Vec<_>>()
        .join("\n")
}
